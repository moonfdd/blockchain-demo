// Copyright 2017 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package bitutil

import (
	"bytes"
	"errors"
	"fmt"
	"testing"

	"github.com/ethereum/go-ethereum/common/bitutil"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

var (
	// errMissingData is returned from decompression if the byte referenced by
	// the bitset header overflows the input data.
	errMissingData = errors.New("missing bytes on input")

	// errUnreferencedData is returned from decompression if not all bytes were used
	// up from the input data after decompressing it.
	errUnreferencedData = errors.New("extra bytes on input")

	// errExceededTarget is returned from decompression if the bitset header has
	// more bits defined than the number of target buffer space available.
	errExceededTarget = errors.New("target data size exceeded")

	// errZeroContent is returned from decompression if a data byte referenced in
	// the bitset header is actually a zero byte.
	errZeroContent = errors.New("zero byte in input content")
)

// 它用于解码带有 0x 前缀的十六进制字符串。如果输入无效，它会触发 panic（在 Go 语言中，panic 是一种运行时错误，它会导致程序立即停止执行，通常用于处理不应该发生的严重错误）
func TestDecodingCycle(t *testing.T) {
	tests := []struct {
		size  int
		input string
		fail  error
	}{
		{size: 0, input: "0x"},

		// Crashers generated by go-fuzz
		{size: 0, input: "0x0020", fail: errUnreferencedData},
		{size: 0, input: "0x30", fail: errUnreferencedData},
		{size: 1, input: "0x00", fail: errUnreferencedData},
		{size: 2, input: "0x07", fail: errMissingData},
		{size: 1024, input: "0x8000", fail: errZeroContent},

		// Tests generated by go-fuzz to maximize code coverage
		{size: 29490, input: "0x343137343733323134333839373334323073333930783e3078333930783e70706336346c65303e", fail: errMissingData},
		{size: 59395, input: "0x00", fail: errUnreferencedData},
		{size: 52574, input: "0x70706336346c65c0de", fail: errExceededTarget},
		{size: 42264, input: "0x07", fail: errMissingData},
		{size: 52, input: "0xa5045bad48f4", fail: errExceededTarget},
		{size: 52574, input: "0xc0de", fail: errMissingData},
		{size: 52574, input: "0x"},
		{size: 29490, input: "0x34313734373332313433383937333432307333393078073034333839373334323073333930783e3078333937333432307333393078073061333930783e70706336346c65303e", fail: errMissingData},
		{size: 29491, input: "0x3973333930783e30783e", fail: errMissingData},

		{size: 1024, input: "0x808080608080"},
		{size: 1024, input: "0x808470705e3632383337363033313434303137393130306c6580ef46806380635a80"},
		{size: 1024, input: "0x8080808070"},
		{size: 1024, input: "0x808070705e36346c6580ef46806380635a80"},
		{size: 1024, input: "0x80808046802680"},
		{size: 1024, input: "0x4040404035"},
		{size: 1024, input: "0x4040bf3ba2b3f684402d353234373438373934409fe5b1e7ada94ebfd7d0505e27be4035"},
		{size: 1024, input: "0x404040bf3ba2b3f6844035"},
		{size: 1024, input: "0x40402d35323437343837393440bfd7d0505e27be4035"},
	}
	for _, tt := range tests {

		data := hexutil.MustDecode(tt.input) //16进制字符串转行成[]byte，入参必须以0x开头，并且是偶数位
		fmt.Println(tt.input)
		fmt.Println(data)
		fmt.Println("----")

	}
}

// 测试压缩算法和解压缩算法，解压缩算法需要知道原数据的长度
func TestCompression(t *testing.T) {
	if false {
		in := hexutil.MustDecode("0x4912385c0e7b64000000")
		out := bitutil.CompressBytes(in) //压缩算法
		fmt.Println("in0 = ", in)
		fmt.Println("out = ", out)

		in1, err := bitutil.DecompressBytes(out, len(in)) //解压缩算法
		if err != nil || !bytes.Equal(in, in1) {
			fmt.Println("未通过0")
			return
		}
		fmt.Println("in1 = ", in1)
	}
	if false {
		in := hexutil.MustDecode("0xdf7070533534333636313639343638373532313536346c1bc33339343837313070706336343035336336346c65fefb3930393233383838ac2f65fefb")
		out := bitutil.CompressBytes(in) //压缩算法
		fmt.Println("in0 = ", in)
		fmt.Println("out = ", out)

		in1, err := bitutil.DecompressBytes(out, len(in)) //解压缩算法
		if err != nil || !bytes.Equal(in, in1) {
			fmt.Println("未通过1")
			return
		}
		fmt.Println("in1 = ", in1)
	}

	if true {
		in1, err := bitutil.DecompressBytes([]byte{0xc0, 0x01, 0x01}, 20000) //输入的压缩数据不符合要求，解压缩失败
		if err != nil {
			fmt.Println("未通过2", err)
			return
		}
		fmt.Println("in1 = ", in1)
	}
}
